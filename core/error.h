/* SPDX-License-Identifier: Apache-2.0 */
#ifndef __CLAP_ERROR_H__
#define __CLAP_ERROR_H__

#include <stddef.h>
#include "compiler.h"
#include "config.h"

/* Error codes */
typedef enum cerr_enum {
    _CERR_OK                     = 0,
    _CERR_NOMEM                  = -1,
    _CERR_INVALID_ARGUMENTS      = -2,
    _CERR_NOT_SUPPORTED          = -3,
    _CERR_INVALID_TEXTURE_SIZE   = -4,
    _CERR_TEXTURE_NOT_LOADED     = -5,
    _CERR_FRAMEBUFFER_INCOMPLETE = -6,
    _CERR_PARSE_FAILED           = -7,
    _CERR_ALREADY_LOADED         = -8,
    _CERR_FONT_NOT_LOADED        = -9,
    _CERR_INVALID_SHADER         = -10,
    _CERR_TOO_LARGE              = -11,
    _CERR_INVALID_OPERATION      = -12,
    _CERR_INVALID_FORMAT         = -13,
    _CERR_INITIALIZATION_FAILED  = -14,
    _CERR_SHADER_NOT_LOADED      = -15,
} cerr_enum;

/****************************************************************************
 * Returning errors std::optional<T> style
 *
 * Functions that return int to indicate error can return cerr. Values of
 * this type can be tested for a error condition with IS_CERR() and the exact
 * error code can be retrieved CERR_CODE().
 *
 * Functions that return anything else can declare an result type with
 * cres_ret(T), cresp_ret(T) (for pointers) or cresp_struct_ret(S) (for
 * pointers to structures), in their header files or whereever the actual
 * type is declared. Then, they can return values with cres_val(T, value),
 * cresp_val(T, value) and errors with cres_error(T, error),
 * cresp_error(T, error) or copied from cerr with cresp_error_cerr(T, cerr_error)
 ****************************************************************************/

/*
 * This is a stand-in for return type int in functions that use int to only indicate
 * success (0) / error (< 0), so it can actually be replaced with:
 *
 * #define cerr cres(int)
 *
 * And then there won't be a need for "cerrs.h". Of course,
 *
 * static_assert(__builtin_types_compatible_p(cres(int), cerr), "cres(int) doesn't match cerr");
 *
 * will fail, of course, because cres(int) has ::value and cerr doesn't.
 */
typedef struct cerr {
    cerr_enum   err;
#ifndef CONFIG_FINAL
    int         line;
    char        *mod;
#endif /* CONFIG_FINAL */
} cerr;

/* Below is generated by scripts/cerr-gen.cmake */
#include "cerrs.h"

#define must_check __attribute__((warn_unused_result))
#define cerr_check cerr must_check

/* Name of a cres type with value type __type */
#define cres(__type) cres_ ## __type
/* Name of a cres type with value type pointer to __type */
#define cresp(__type) cres_ ## __type ## p

/*
 * Non-release builds retain file name and line number where
 * the error originated
 */
#ifndef CONFIG_FINAL
#define __cerr_debug_fields \
    int         line;       \
    char        *mod;
#define __cerr_debug_data \
    .line   = __LINE__,   \
    .mod    = MODNAME,
#define __cerr_debug_copy(__err) \
    .line   = (__err).line,   \
    .mod    = (__err).mod,
#else
#define __cerr_debug_fields
#define __cerr_debug_data
#define __cerr_debug_copy(x)
#endif /* CONFIG_FINAL */

/* Declare a cres with value type __type */
#define cres_ret(__type) \
    typedef struct cres(__type) { \
        cerr_enum   err; \
        __cerr_debug_fields \
        __type      val; \
    } cres(__type)

/* Declare a cres with value type pointer to __type */
#define cresp_ret(__type) \
    typedef struct cresp(__type) { \
        cerr_enum   err; \
        __cerr_debug_fields \
        __type      *val; \
    } cresp(__type)

/* Declare a cres with value type pointer to struct __struct */
#define cresp_struct_ret(__struct) \
    typedef struct cresp(__struct) { \
        cerr_enum       err; \
        __cerr_debug_fields \
        struct __struct *val; \
    } cresp(__struct)

#define cres_check(__type) cres(__type) must_check
#define cresp_check(__type) cresp(__type) must_check

/* Declare cres with int value */
cres_ret(int);

/*
 * Make sure that cerr and cres(T) have err, mod and line at same offsets, so
 * both can be typecast to cerr and passed into cerr_strbuf()
 */
static_assert(offsetof(cerr, err)  == offsetof(cres(int), err),  "cerr/cres::err don't match");
#ifndef CONFIG_FINAL
static_assert(offsetof(cerr, mod)  == offsetof(cres(int), mod),  "cerr/cres::mod don't match");
static_assert(offsetof(cerr, line) == offsetof(cres(int), line), "cerr/cres::line don't match");
#endif /* CONFIG_FINAL */

/* Get error value from cerr/cres */
#define CERR_CODE(__x) (*((cerr_enum *)&(__x)))
/* Is cerr or cres (or any compound type that has cerr at offset 0) an error */
#define IS_CERR(__x) (CERR_CODE(__x) != _CERR_OK)

/* Return an error */
#define cres_error(__type, __err) ({ \
    cres(__type) __res = { \
        .err = (_ ## __err), \
        __cerr_debug_data \
    }; \
    __res; \
})

/* Return an error */
#define cresp_error(__type, __err) ({ \
    cresp(__type) __res = { \
        .err = (_ ## __err), \
        __cerr_debug_data \
    }; \
    __res; \
})

/* Copy an error from cerr */
#define cres_error_cerr(__type, __err) ({ \
    cres(__type) __res = { \
        .err = (__err).err, \
        __cerr_debug_copy(__err) \
    }; \
    __res; \
})

/* Copy an error from cerr */
#define cresp_error_cerr(__type, __err) ({ \
    cresp(__type) __res = { \
        .err = (__err).err, \
        __cerr_debug_copy(__err) \
    }; \
    __res; \
})

/* Copy an error from cres */
#define cerr_error_cres(__err) ({ \
    cerr __res = { \
        .err = (__err).err, \
        __cerr_debug_copy(__err) \
    }; \
    __res; \
})

/* Return a value */
#define cres_val(__type, __val) ({ \
    cres(__type) __res = { \
        .err = _CERR_OK, \
        __cerr_debug_data \
        .val = (__val), \
    }; \
    __res; \
})

/* Return a value */
#define cresp_val(__type, __val) ({ \
    cresp(__type) __res = { \
        .err = _CERR_OK, \
        __cerr_debug_data \
        .val = (__val), \
    }; \
    __res; \
})

/* Error code to text mapping */
const char *cerr_str(cerr_enum err);
int cerr_strbuf(char *buf, size_t size, void *err);

#endif /* __CLAP_ERROR_H__ */
